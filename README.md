### 62 搜索旋转排序数组
**解析：**  二分查找，时间复杂度O(logN)，空间复杂度O(1)
先确定mid的位置，然后确定左半边是否顺序，如果是顺序的，则继续判断target是否在该范围内，如果在则令last等于mid，否则令first等于mid+1。如果左半边不是顺序的，那么右半边一定是顺序的，同样，判断target是否在右半边范围内，如果在，则令first等于mid+1，否则令last等于mid。
### 63 搜索旋转排序数组 II
**解析：**  二分查找，时间复杂度O(logN)，空间复杂度O(1)
先确定mid的位置，然后判断A[first] < A[mid]，如果成立，则说明数组在[first,mid]区间递增，反之，在[mid,first]递增（旋转过的数组，第一个数字一定大于等于最后一个数字），如果A[first] = A[mid]，则令first++，跳过重复的数字。
### 101 删除排序数组中的重复数字 II
**解析：**  时间复杂度O(n)，空间复杂度O(1)。  
方法一：数组是排好序的，使用一个index，初始化为0，然后使用for循环从1开始，与nums[index]比较，如果有重复，则令标志位等于1，表示该数字已经重复了两次，并令nums[++index] = nums[i]。否则，什么都不做，让i+1。如果遇到不相等，令则标志位等于0，nums[++index] = nums[i]。   
方法二：使用一个index，然后for循环从2开始，nums[i]与nums[index-2]比较，不相等则nums[index++] = nums[i]，否则i继续往后遍历。